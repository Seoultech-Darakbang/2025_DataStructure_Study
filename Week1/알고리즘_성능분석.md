# 2. 알고리즘 성능 분석

## 알고리즘이란?
: 주어진 **문제를 해결하는 방법을 추상화하여** 일련의 **단계적 절차**를 논리적으로 기술해 놓은 명세서이다.
: 문제를 해결하기 위한 단계적 절차

### 자료구조를 공부하는데 왜 갑자기 알고리즘이 등장했을까?
자료구조는 알고리즘이 데이터를 효율적으로 사용할 수 있게 도와주기 때문입니다. 

**ex) 다이소에서 원하는 물건을 찾는다.**
- 다이소는 제품을 카테고리별로 분류를 해두고 위에 펫말을 달아둔다.
- 원하는 물건을 찾으려면(알고리즘)
  - -> 해당 물건의 카테고리 코너로 가면 된다.
  - ex) 우유를 사야 한다면 유제품 코너로 가면 된다

만약에 마트에 제품이 아무렇게나 놓여 있다면, 아무리 좋은 탐색 알고리즘이 있어도 물건을 찾는 데 시간이 오래 걸린다.
**즉, 자료구조가 잘 되어 있어야 알고리즘이 효과적으로 작동할 수 있다.** 알고리즘과 땔 수 없는 관계를 갖는게 자료구조다~

## 효과적인 알고리즘의 조건
1. 입력: 알고리즘을 수행하는 데 필요한 자료가 외부에서 입력되어야 한다.
2. 출력: 알고리즘을 수행하고 나면 결과를 하나 이상 출력해야 한다.
3. 명확성: 수행할 작업의 내용과 순서를 나타내는 알고리즘의 명령어는 명확하게 명세되어야 한다.
4. 유한성: 알고리즘을 모두 수행하고 나면 반드시 종료되어야 한다.
5. 효과성: 알고리즘의 모든 명령어는 기본적이며 실행할 수 있어야 한다

중요한 개념은 아니다. 당연한 말들이고, 그냥 시험공부할 때 외워두면 된다.

## 알고리즘의 표현 방법
1. 자연어를 이용한 서술적 표현
2. 순서도를 이용한 도식화
3. 프로그래밍 언어를 이용한 구체화
4. 가상코드(슈도코드)를 이용한 추상화

중요한 내용이 아니니 이렇게 표현할 수 있구나 ~ 정도만 알고 넘어가자. 시험공부할 때 순서도 그리는 방법 정도만 외워두면 된다.

## 알고리즘의 성능 분석
문제 정의 -> 문제 해결 방법 1, 2, 3, …
이 중에서 가장 최적의 방법을 선택해야 한다. “최적”의 기준이, 컴퓨터에서는 “성능”이다.

### 알고리즘 성능 분석의 판단 기준  
| 판단 기준  | 설명 |
|------------|-------------------------------------------------------------|
| **정확성** | 올바른 입력이 주어졌을 때, 유한한 시간 내에 올바른 결과를 출력하는가 |
| **명확성** | 알고리즘이 이해하기 쉽고, 변경 및 수정이 용이한가 |
| **수행량** | 알고리즘의 특성을 나타내는 중요 연산을 분석하여 성능을 판단 |
| **메모리 사용량** | 알고리즘이 실행될 때 사용하는 메모리의 양을 고려 |
| **최적성** | 주어진 사용 환경과 요구사항에 가장 적합한 최적의 알고리즘인가 |

가장 좋은 알고리즘이란 **절대적인 것이 아니라** 특정 **환경과 요구사항에 맞는 최적의 알고리즘**을 의미한다. (최적성)

### 알고리즘 성능 분석 방법
정확성, 명확성, 최적성 -> 주관적이다.
수행량과 메모리 사용량은 어느정도 절대적인 수치로 나타낼 수 있다. 

그래서 알고리즘 성능 분석의 지표로 수행량, 메모리 사용량을 사용을 합니다.
- 연산 수행량 -> 시간 복잡도
- 메모리 사용량 -> 공간 복잡도

### 공간 복잡도
알고리즘을 프로그램으로 실행하여 완료하는 데까지 필요한 총 저장 공간을 의미한다

#### 저장 공간: **고정 공간과 가변 공간**
**ex) 시험 공부**
시험 공부를 위해 단어를 외워야 한다. 단어를 적어두기 위해 **노트를 사용할지, 포스트잇을 사용할지** 결정해야 한다.
(1장에 단어 1개만 적을 수 있다고 해보자.)
* **노트**
  * 미리 100장짜리 노트를 준비합니다.
  * 하지만 단어를 50개만 외웠다면? 👉 남은 50장의 노트가 낭비됨.
  * 반대로 120개가 필요하면? 👉 새로운 노트를 준비해야 해서 불편함.
* **포스트잇**
  * 단어를 하나 외울 때마다 포스트잇을 하나씩 붙여서 확장 가능.
  * 50개만 필요하면 50장만 사용!

**고정 공간**
- 노트: 공간이 더 늘어나지도, 줄지도 않는다. 고정적이다.
- 프로그램 크기나입출력 횟수와는 상관없이 고정적으로 필요한 저장 공간으로 프로그램 저장 공간과 변수 및 상수를 저장하는 공간이다
- 메인 함수 안에 `int arr[100];` 선언

**가변 공간**
- 포스트잇: 외우는 과정에서 포스트잇 하나씩 붙인다 -> 사용하는 공간을 가변적으로 늘린다.
- 실행 과정에서 사용하는 자료와 변수를 저장하는 공간 + 함수를 실행하는 데 관련 있는 정보를 저장하는 공간
- 동적 할당: `int* arr = new int[10];`
- 함수 실행: A라는 함수 안에 지역 변수로  `int arr[100];` 가 선언되어 있다.
  - 이 함수를 호출한다면 100칸 만큼의 공간을 더 사용하는 것이고, 호출하지 않으면 100칸 공간은 사용X

프로그램을 수행할 때 고정 공간만 사용하는 것도 아니고, 가변 공간만 사용하는 것도 아니다. 
공간 복잡도는 필요한 고정 공간과 가변 공간을 합하여 구한다.

### 시간 복잡도
- 시간 복잡도는 알고리즘을 프로그램으로 실행하여 완료하는 데까지 소요되는 시간이다
- 엄밀하게는 컴파일 시간 + 실행 시간
- 컴파일은 프로그램 시작 전에 1번 진행. 정적 -> 시간 복잡도에서 크게 신경쓰지 않음.
- 같은 프로그램을 실행하더라도, 컴퓨터 스펙에 따라 실행 시간이 달라질 수 있다.
  - 실제 실행 시간이 아니라, 명령문의 실행 빈도수를 계산해서 사용한다.

**ex) 피보나치 수열**
```c
#include <stdio.h>

int fibonacci(int n) {
    if (n < 0) {
        return -1; // 음수 입력 방지
    }
    if (n <= 1) {
        return n;
    }

    int fn1 = 0, fn2 = 1, fn;
    
    for (int i = 2; i <= n; i++) {
        fn = fn1 + fn2; // fn을 fn-1 + fn-2를 통해 구한다.
        fn1 = fn; // 다음 루프를 위해 fn-1 자리에 fn을 대입한다.
        fn2 = fn1; // // 다음 루프를 위해 fn-2 자리에 fn-1을 대입한다.
    }

    return fn;
}
```

n > 1이라면, 실행 빈도 함수는 4n + 2가 된다.

### 알고리즘 성능 분석 표기법
알고리즘 성능 분석의 기준인 시간 복잡도, 공간 복잡도 중 일반적으로는 시간 복잡도를 더 중요시 한다. 
일반적으로 CS에서 “성능”이라고 하면 시간과 관련된다고 보면 된다.

**이유**
- 하드웨어 발전으로 메모리는 저렴해졌지만, 시간은 여전히 제한적
  - 과거에는 메모리 용량이 제한적이었지만, 현대 컴퓨터에서는 **RAM, 저장 장치(SSD, HDD) 등 하드웨어가 발전하여 저장 공간이 충분**합니다. 하지만, **CPU 속도에는 물리적인 한계가 있기 때문에 연산을 빠르게 수행하는 것이 더 중요**합니다.
  - 메모리는 부족하면 늘려주면 된다.

> 물론 공간 복잡도가 의미없는건 아니다. 메모리의 접근에 따른 속도 자체가 증가하기 때문이다.

알고리즘이라는 건 어느정도 추상화되어 있는 거지만, 주어진 상황에 맞게 실제 코드로 구현을 하면 조금씩 차이가 난다.
어떤 경우에는 실행 빈도 함수가 4n^2 + 2n + 1, 어떤 경우에는 4n^2 + 1, 어떤 경우에는 …
일관성 있게 시간 복잡도를 표기하면 좋겠다. (= 알고리즘 성능 분석 표기) -> 점근적 분석의 등장

#### 점근적 분석
실행 빈도 함수에서 입력 크기 n에 대한 실행 시간의 증가율만 분석한다.

- **이유1:** 입력 크기(n)가 커질 때 성능 예측
  - 작은 입력에서는 차이가 작지만, 큰 입력에서는 차이가 커짐
- **이유2**: 단순한 연산보다는 알고리즘의 핵심 성능만 분석하여 핵심적인 성능을 분석하기 위해
  - 입력의 크기랑 관련 없는 연산을 성능 분석에서 할 필요가 없다.
- 기타 등등
- ex) 4n^2 + 2n + 1
  - -> 4n^2 + 2n

알고리즘의 정확한 실행 시간을 계산하는 것이 아니라, **데이터 양의 증가에 따른 성능의 변화 추세를 이해하는 것이 중요!**

**차수 표기법:** 실행 빈도 함수의 상수항과 계수는 무시하고 n의 증가에 따라 증가율이 가장 큰 하나의 항을 표기
- **이유1**: n이 커지면 커질수록 증가율이 가장 큰 하나의 항의 상대적인 영향력이 매우 커져서, 나머지 항은 무시 가능
  - 고등학교 때 수학 시간에 배운 극한을 생각해보자
- **이유2**: 알고리즘을 직관적으로 비교하기 위함.
- 기타 등등
- ex) 4n^2 + 2n + 1
  - n^2

그냥 n^2 이렇게 써두면 수식인지, 시간 복잡도 표기인지 알 수가 없다 -> 시간 복잡도를 나타내는 표기법이 필요.

### 시간 복잡도 표기법
1. 빅-오 표기법
   - 상한
2. 빅-오메가 표기법
   - 하한
3. 빅-세타 표기법
   - 상한과 하한의 일치

#### 빅-오 표기법(중요)
- 표기: O(f(n))
- 정의: 책 참고

f(n)이 실행 빈도 함수라고 해보자.
입력의 크기 n이 어느 특정 값(n_0)을 넘어선 이후부터, f(n)이 절대 넘을 수 없는 c x g(n)이 존재한다면, f(n) = O(g(n))이다. 
- 즉, g(n) 은 상한
- “복잡해봐야”, “높아봐야”, “최대로 하여도”, “재수가 없더라도”
- 책에 “다시 말해 최악의 경우에도 g(n) 의 수행 시간 안에는 알고리즘 수행이 완료된다는 것을 보장한다.” 라고 나와 있다.
  - 헷갈림 주의! **상한과 최악은 같은 개념이 아닙니다. 상한 != 최악**
  - 최악의 경우에서 빅-O 표기법을 쓰면 최악의 수행 시간의 상한이 되고, 최선의 경우에서 빅-O 표기법을 쓰면 최선의 수행 시간의 상한이 된다.
  - 몇몇 책에서 “빅-O 표기법은 최악의 경우를 다룰 때 사용한다” 라고 하는데, 이는 잘못된 오개념이다.
  - 단지 최악의 경우 및 빅-O 표기법을 가장 많이 쓸 뿐이다.

----
#### 최악의 경우와 최선의 경우
여러분이 방금 자료구조 중간고사 시험을 봤다고 해보자. 시험이 막 끝나서 정확한 점수는 몰라도 어느정도 예상은 할 수 있다.
최악의 경우(실수를 꽤 했을 때)와 최선의 경우(시도한 문제들의 풀이가 완벽할 때) 얼마나 받을지 예상을 해봅니다.

* "못 봐도 80점은 나오지 않을까?"라고 답한다면, "못 봐도"는 최악의 경우, "80점"은 예상 점수의 하한입니다. 아무리 실수를 많이 해서 마구 틀리더라도 적어도 80점은 될 것 같다는 뜻입니다.
* "잘 보면 90점도 나올 것 같아!"라고 답한다면, "잘 보면"은 최선의 경우, "90점"은 예상 점수의 하한입니다. 정말 잘 봐서 시도한 모든 풀이가 완벽하면 적어도 90점은 될 것 같다는 뜻입니다.
* "못 보면 70점 밑으로도 갈 것 같아..."라고 답한다면, "못 보면"은 최악의 경우, "70점"은 예상 점수의 상한입니다.
* "잘 봐도 60점 안 될 거야......"라고 답한다면, "잘 봐도"는 최선의 경우, "60점"은 예상 점수의 상한입니다. 괜찮습니다. 기말고사를 잘 보면 되죠.

---------

- g(n)이 상한이다 == n0 이상에서 g(n)이 f(n)보다 빠르게 증가한다.

> 루트n의 경우 n과 logn 사이

정의는 거창한데, 빅오 표기법으로 시간복잡도를 표현하는 건 매우 쉽다.
1. 최고차항 or 가장 영향력이 쌘 항을 제외하고 제거
2. 계수 제거
3. O( ) 괄호 안에다가 넣기

**예시**
- 4n^2 + 2n + 1
  - O(n^2)


#### 빅-오메가 표기법
- 표기법: Ω(f(n))
- 정의: 책 참고
f(n)이 실행 빈도 함수라고 해보자.
입력의 크기 n이 어느 특정 값(n_0)을 넘어선 이후부터, f(n)을 절대 넘을 수 없는 c x g(n)이 존재한다면, f(n) = O(g(n))이다. 
- 즉, g(n) 은 하한
- “아무리 운이 좋아도”, “최소한”, “적어도” 이 정도는 걸린다.
- 몇몇 책에서 “빅-Ω 표기법은 최선의 경우를 다룰 때 사용한다” 라고 하는데, 잘못된 오개념입니다.

**예시**
- f(n) = n^3 + n^2 + 1
  - Ω(n)
  - Ω(n^2)
  - Ω(n^3)

#### 빅-세타 표기법
- 표기법: θ(f(n))
- 정의: 책 참고
f(n)이 실행 빈도 함수라고 해보자.
입력의 크기 n이 어느 특정 값(n_0)을 넘어선 이후부터, 상한과 하한을 동시에 만족하는 g(n)이 존재한다면, f(n) = θ(g(n))
- 상한과 하한의 일치
- 빅-세타 표기법은 상한과 하한이 같은 정확한 차수를 표현하기 위한 표기법
- 즉, 빅-오메가 표기와 빅-세타 표기가 같은 경우에 사용
- 예시
  - f(n) = 5n^2 + 3n - 10 = O(n^2) = Ω(n^2) 이므로, f(n) = θ(n^2)

### 빅-오 표기법을 제일 많이 사용한다.
이유 -> 최악의 경우 분석이 중요하기 때문이다.
n = 5 인 배열에서, 10을 찾는다고 해보자.
최선의 경우에 1번만에 찾을 수도 있지만, 최악의 경우 2번 인덱스를 마지막으로 방문해 n번 비교 연산을 해야할 수도 있다.

최선의 경우를 다루는게 의미가 있을까? 항상 최선이 아니므로 크게 의미가 없다.
최악의 경우 상한선을 정해주는게 훨씬 의미가 있다. 최악의 경우 상한선은 어떤 경우에도 보장이 되는 값이다. 
상한을 다루는 표기법이 빅-오 표기법이기 때문에, 빅-오 표기법을 제일 많이 사용한다.

앞으로 자료구조를 알고리즘을 배우고, 백준 문제를 풀고, 이러다 보면 대부분 빅-오 표기법을 사용하는 경우가 많다. 

뿐만 아니라, 자료구조를 비롯한 운영체제, 데이터베이스 이런 이론들을 배우다 보면, 항상 최악의 경우를 대비하게 된다. 
- ex) 자율주행 차량, 의료 장비, 항공 교통 제어 시스템, 서버가 터지지 않을 메모리의 상한선

**평균적인 경우**
- 일반적으로 등장하는 상황에 대한 경우의 수이다. 
- 최선의 경우와 달리 알고리즘 평가에 도움이 된다.
- 하지만 계산하기가 어렵다.
- 평균적인 경우임을 증명하기 어렵다. (보통 확률적으로 계산을 합니다.)


## 연습문제
**T/F**
1. 추상 데이터 타입은 구현의 세부적인 사항을 무시한다.
2. 빅-O 표기법은 최악의 경우를 다룰 때 사용한다.
3. 알고리즘 성능 분석 표기법으로 시간 복잡도를 사용한다.
4. 가장 좋은 알고리즘은 연산량이 적은 알고리즘이다.

**주관식**
f(n) = n! + n^n + 1일 때, 빅-오 표기법으로 시간복잡도를 표현

## 정리
오늘까지 배운 내용은 자료구조를 배우고 분석하기 위한 배경지식을 배웠다고 생각하면 됩니다. 다음주부터는 본격적으로 자료구조 하나 하나 살펴보면서 코드도 직접 작성해볼 예정입니다.

코드를 작성하기 위해서는 C언어에 대한 배경지식이 필수입니다. 까먹었다면 다음주까지는 복습해오는 걸 권장합니다.
(챕터 2의 배열, 포인터, 구조체에 관한 내용은 스터디에서 진행하지 않습니다. 다음주에는 2-4. 재귀호출부터 바로 진행할 예정입니다.)

Ref): https://www.acmicpc.net/blog/view/136

